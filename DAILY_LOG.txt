Build my 80024_SD_SPI project.
  No Errors...

Where was I... it's been a while since I've opened this project.  Been working so many days on Unity makefiles... forgot what goes on here :/

volatile pointer errors...

"When thinking about pointers, it helps to draw diagrams. A pointer is an arrow that points to an address in memory, with a label indicating the type of the value. The address indicates where to look and the type indicates what to take. Casting the pointer changes the label on the arrow but not where the arrow points."

Note to self: namespace collisions are really bad and take a long time to resolve.

So all I really had to do was insert the HAL_Delay() function into my code but because the header file it comes from also had a lot of the same register names that I'm using... there were naming collisions all over the place.  All that work... just to get HAL_Delay() working.  Ew.

And... at this point I'm pretty lost.  My driver isn't quite working right... there is weird behavior.  No build errors, and SPI sends SOMETHING but it doesn't seem to send the right data...  Actually never mind.  After my last change, NOTHING works.

Ok, even after git-resetting... it still doesn't work.  WTF.

Checked the wiring... everything seem sok.  WHY??  I really don't want to spend time debugging this.  I'd rather start the project over and start with a test framework that essentially documents the driver as I go.

Start fresh.

Try to build it.  It seems to build.  Now time to start the arduous process of setting up registers and testing them.  I need a breakk I think... so I can reogranize my thoughts.
-------------------------------------------------------------------------------------------

1:10 PM 11/22/2020

Name my driver file  dc_gpio_driver.c
	-> Which means all functions in this file should start with DGD_FunctionName()
	-> First three letter should be capitalized letters of first letter in each file name word, followed by an underscore, followed by PascalCase for function name
	-> This helps avoid name collisions with other files
	-> Cool...

Time to add unity to project so TDD can begin.

Done.  I've added the unity framework and can build/run tests.

I've run into an issue.  When testing registers are set with correct values, I use virtual registers... But.. to test this, I need the production code to accept the address of the register they should modify.  However, this opens a big can of worms.  Does EVERY single one of my functions need to accept the address of a virtual entity so that I can switch between virtual and real hardware... something doesn't seem right.

In the TDD book, they use virtualLEDs as a way to test if the LED register is being set correctly.  But, in my case, I need to set lots of registers.  How can I unit test that?

Well, let's start at the bottom.  I need to write a function that simply sets a bit, forget about which register, just any register.
-------------------------------------------------------------------------------------------

12:46 PM 11/23/2020

Set up the RCC gpio port clock enable during the initialization routine.

Time to set up I/O pin configuration... but I'm a bit stuck.  I know that I need a way to select between all the ports, pins, AND modes.  On top of any other configuration details if the mode is an alternate function or analog I/O.  How can I manage this?  I can't just use nested switch statements everywhere.
  -> I'm hazarding a guess that I need to build down before I can build up.  I.E. I need functionality that does each one of these things one at a time.

The issue is, configuration options in these registers is all over the place.  Some config options are 1 bit wide, some are 2 bits wide... some more.  On top of that, they happen in different registers.
  -> Maybe this is where the human configuration struct is useful... I can set up the configuration in plain english for a pin.  THEN, I can have a DGD_ConfigureGPIOPin() function to decypher all the english into bits and registers without the client having to worry about it.

For example, GPIOx_MODER register needs 2 bits at a certain location to set a GPIO pin as input/output/alternate function/analog .  2 bits... at some location.  I'd think I could use this as a way to create a generalized function.

Something like...
DGD_SetRegisterField(uint32_t *regAddr, uint8_t width, uint8_t location, uint8_t setting)

Then I could do something like

/* Create bit mask from bit field width */
uint32_t bitMask = 0;
int i = width;
while(i > 0)
{
    bitMask |= (1 << i);
    i--;
}

/* Configure the bits to correct setting */
bitMask = bitMask & (~bitMask | setting);

/* Move bit mask to correct position */
bitMask = bitMask << location;

/* Finally merge the configured bit mask into the register */
... NO NO NO... this doesn't work well.
