Build my 80024_SD_SPI project.
  No Errors...

Where was I... it's been a while since I've opened this project.  Been working so many days on Unity makefiles... forgot what goes on here :/

volatile pointer errors...

"When thinking about pointers, it helps to draw diagrams. A pointer is an arrow that points to an address in memory, with a label indicating the type of the value. The address indicates where to look and the type indicates what to take. Casting the pointer changes the label on the arrow but not where the arrow points."

Note to self: namespace collisions are really bad and take a long time to resolve.

So all I really had to do was insert the HAL_Delay() function into my code but because the header file it comes from also had a lot of the same register names that I'm using... there were naming collisions all over the place.  All that work... just to get HAL_Delay() working.  Ew.

And... at this point I'm pretty lost.  My driver isn't quite working right... there is weird behavior.  No build errors, and SPI sends SOMETHING but it doesn't seem to send the right data...  Actually never mind.  After my last change, NOTHING works.

Ok, even after git-resetting... it still doesn't work.  WTF.

Checked the wiring... everything seem sok.  WHY??  I really don't want to spend time debugging this.  I'd rather start the project over and start with a test framework that essentially documents the driver as I go.

Start fresh.

Try to build it.  It seems to build.  Now time to start the arduous process of setting up registers and testing them.  I need a breakk I think... so I can reogranize my thoughts.
-------------------------------------------------------------------------------------------

1:10 PM 11/22/2020

Name my driver file  dc_gpio_driver.c
	-> Which means all functions in this file should start with DGD_FunctionName()
	-> First three letter should be capitalized letters of first letter in each file name word, followed by an underscore, followed by PascalCase for function name
	-> This helps avoid name collisions with other files
	-> Cool...

Time to add unity to project so TDD can begin.

Done.  I've added the unity framework and can build/run tests.

I've run into an issue.  When testing registers are set with correct values, I use virtual registers... But.. to test this, I need the production code to accept the address of the register they should modify.  However, this opens a big can of worms.  Does EVERY single one of my functions need to accept the address of a virtual entity so that I can switch between virtual and real hardware... something doesn't seem right.

In the TDD book, they use virtualLEDs as a way to test if the LED register is being set correctly.  But, in my case, I need to set lots of registers.  How can I unit test that?

Well, let's start at the bottom.  I need to write a function that simply sets a bit, forget about which register, just any register.
-------------------------------------------------------------------------------------------

12:46 PM 11/23/2020

Set up the RCC gpio port clock enable during the initialization routine.

Time to set up I/O pin configuration... but I'm a bit stuck.  I know that I need a way to select between all the ports, pins, AND modes.  On top of any other configuration details if the mode is an alternate function or analog I/O.  How can I manage this?  I can't just use nested switch statements everywhere.
  -> I'm hazarding a guess that I need to build down before I can build up.  I.E. I need functionality that does each one of these things one at a time.

The issue is, configuration options in these registers is all over the place.  Some config options are 1 bit wide, some are 2 bits wide... some more.  On top of that, they happen in different registers.
  -> Maybe this is where the human configuration struct is useful... I can set up the configuration in plain english for a pin.  THEN, I can have a DGD_ConfigureGPIOPin() function to decypher all the english into bits and registers without the client having to worry about it.

For example, GPIOx_MODER register needs 2 bits at a certain location to set a GPIO pin as input/output/alternate function/analog .  2 bits... at some location.  I'd think I could use this as a way to create a generalized function.

Something like...
DGD_SetRegisterField(uint32_t *regAddr, uint8_t width, uint8_t location, uint8_t setting)

Then I could do something like

/* Create bit mask from bit field width */
uint32_t bitMask = 0;
int i = width;
while(i > 0)
{
    bitMask |= (1 << i);
    i--;
}

/* Configure the bits to correct setting */
bitMask = bitMask & (~bitMask | setting);

/* Move bit mask to correct position */
bitMask = bitMask << location;

/* Finally merge the configured bit mask into the register */
... NO NO NO... this doesn't work well.

-------------------------------------------------------------------------------------------

2:17 PM 11/24/2020

Finally reaching out to people for ideas on how to mount this interface issue... I don't know how to create a easily manageable way to modify lots of registers and subfields.

One suggestion I received is to make a GPIO_Port_t type (which I already have) but to associate the base address of the PORT register with the type.  Then somehow use this type to associate the address offsets for all the individual registers and bits of each port.  Not clear yet but some light at the end of the tunnel...


Here's what I know.  My PORT register offset can be encapsulated in a struct:

typedef struct
{
  __IO uint32_t MODER;    /*!< GPIO port mode register,               Address offset: 0x00      */
  __IO uint32_t OTYPER;   /*!< GPIO port output type register,        Address offset: 0x04      */
  __IO uint32_t OSPEEDR;  /*!< GPIO port output speed register,       Address offset: 0x08      */
  __IO uint32_t PUPDR;    /*!< GPIO port pull-up/pull-down register,  Address offset: 0x0C      */
  __IO uint32_t IDR;      /*!< GPIO port input data register,         Address offset: 0x10      */
  __IO uint32_t ODR;      /*!< GPIO port output data register,        Address offset: 0x14      */
  __IO uint32_t BSRR;     /*!< GPIO port bit set/reset register,      Address offset: 0x18      */
  __IO uint32_t LCKR;     /*!< GPIO port configuration lock register, Address offset: 0x1C      */
  __IO uint32_t AFR[2];   /*!< GPIO alternate function registers,     Address offset: 0x20-0x24 */
} GPIO_TypeDef;


Then, each specific port can be accessed like this:

#define GPIOA               ((GPIO_TypeDef *) GPIOA_BASE)
#define GPIOB               ((GPIO_TypeDef *) GPIOB_BASE)
#define GPIOC               ((GPIO_TypeDef *) GPIOC_BASE)


I.E.

GPIOA->MODER to set the MODER register of PORTA.  Great.  But, I still need a way to access this inside a function.

Maybe I can do something like

Write_GPIO_Pin(GPIO_TpeDef *port, uint8_t pin, uint8_t level)
{
  port->MODER = // set to output
  port->ODR = // set correct pin to output
}



-------------------------------------------------------------------------------------------

12:11 PM 11/25/2020

I think I'm doing something fundamentally flawed.  My interface design doesn't really hide details of the inner workings.

If I'm a client of dc_gpio_driver.h, all I want to be able to do is... do things like this:

DGD_Write_GPIO_Pin(port, pin, level) // unsure about what the type of each argument should be

Maybe the gpio_driver interface can provide the client with a list of possible options.  In fact, it SHOULD.  To prevent the client from having to dig into the driver code AT ALL.  Like... I don't want the client to be reponsible for comming up with the correct address.  That would be insane... what's even the point of my driver if the client has to go into the datasheet or the MCU specific header file.  Pointless..

Ok so I know that my driver should offer the functions and the OPTIONS for the functions that the client should know about.  Like... a radio interface.  Only certain knobs are exposed and only certain knob values can be achieved unless the knob is like a potentiometer.


-------------------------------------------------------------------------------------------

1:34 PM 11/27/2020

Well I finally got a basic GPIO interface going.  It's still rough.  The associated tests are even more rough.  Not super happy about how development for this has gone but at least I learned how to make a basic GPIO interface as a starting point.  Where can I go next?

Well, let's flesh out the GPIO driver interface.



-------------------------------------------------------------------------------------------

4:46 PM 11/28/2020

Getting a warning I don't understand.

warning: passing argument 1 of 'DGD_SetBit' makes pointer from integer without a cast [-Wint-conversion]

-->function declaration
void DGD_SetBit(uint32_t *address, uint8_t bit)

-->function call
DGD_SetBit(activeGPIOhandle.portRegisters->MODER, 0);

What I don't get is... the function expects a pointer to uint32_t.  OOOOH.  I'm passing in the VALUE of the register.  I need to pass in the address.

Fixed it... SetBit() and ClearBit() should have volatile qualifier on the first parameter since they pretty much always modify hardware registers.  If I happen to pass in a register that is not tied to actual hardware, I only lose out on a bit of optimization.

At some point I need to graduate past making snail paced progress on the GPIO driver.  Trying to finish up write/read GPIO functionality.

Order this book: "Small Unmanned Aircraft: Theory and Practice"



-------------------------------------------------------------------------------------------

4:01 PM 11/29/2020

It's becoming evident that I am trying to invest too much energy into making the GPIO driver perfect.  While at the same time trying to think about how to make the lessons I learn making the GPIO driver applicable to other drivers.  Or to embedded programming in general.  There's so much to think about and I trying to do it all in parallel is REALLY slowing me down.  It might be smarter to try finishing the GPIO driver to the best of my ability for now and moving on to other interfaces (like maybe an interrupt management interface since most likely that will be used in lots of places anyway).  That way I don't have to spend too much time worrying about what's worth working on next.  Just pick the most general pieces and move inward towards the final solution.

So in my case, it might be wise to finish my GPIO driver interface with 
DGD_InitPort(enum port) // turn on RCC to port
DGD_DeInitPort(enum port) // maybe turn off (tri-state) the output pins and turn off RCC to port
DGD_SetPinDirection(enum port, pin, mode)
DGD_WritePin(enum port, pin, level)
DGD_ReadPin(enum port, pin)


Just as a comparison point, looking through my old flight controller project, I didn't do a great job of defining the interfaces clearly out of modules.  There's so much overlap, i.e. motorControl.c has a PUBLIC function named GatherSensorData()... no way does that make sense.  I'm inputting sensor aquisition logic into the motorControl driver... no.  Now it MAY be possible that I meant this function to be internal and private to the motorControl, but if that's the case I totally forgot to prefix it as "static".  Yeah, either way I look at it, the lesson is that motorControl seems to have logic associated with sensor data and that just doesn't make sense.  So I am learning!  Yaya!
