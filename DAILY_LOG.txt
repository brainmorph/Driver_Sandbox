Build my 80024_SD_SPI project.
  No Errors...

Where was I... it's been a while since I've opened this project.  Been working so many days on Unity makefiles... forgot what goes on here :/

volatile pointer errors...

"When thinking about pointers, it helps to draw diagrams. A pointer is an arrow that points to an address in memory, with a label indicating the type of the value. The address indicates where to look and the type indicates what to take. Casting the pointer changes the label on the arrow but not where the arrow points."

Note to self: namespace collisions are really bad and take a long time to resolve.

So all I really had to do was insert the HAL_Delay() function into my code but because the header file it comes from also had a lot of the same register names that I'm using... there were naming collisions all over the place.  All that work... just to get HAL_Delay() working.  Ew.

And... at this point I'm pretty lost.  My driver isn't quite working right... there is weird behavior.  No build errors, and SPI sends SOMETHING but it doesn't seem to send the right data...  Actually never mind.  After my last change, NOTHING works.

Ok, even after git-resetting... it still doesn't work.  WTF.

Checked the wiring... everything seem sok.  WHY??  I really don't want to spend time debugging this.  I'd rather start the project over and start with a test framework that essentially documents the driver as I go.

Start fresh.

Try to build it.  It seems to build.  Now time to start the arduous process of setting up registers and testing them.  I need a breakk I think... so I can reogranize my thoughts.
-------------------------------------------------------------------------------------------

1:10 PM 11/22/2020

Name my driver file  dc_gpio_driver.c
	-> Which means all functions in this file should start with DGD_FunctionName()
	-> First three letter should be capitalized letters of first letter in each file name word, followed by an underscore, followed by PascalCase for function name
	-> This helps avoid name collisions with other files
	-> Cool...

Time to add unity to project so TDD can begin.

Done.  I've added the unity framework and can build/run tests.

I've run into an issue.  When testing registers are set with correct values, I use virtual registers... But.. to test this, I need the production code to accept the address of the register they should modify.  However, this opens a big can of worms.  Does EVERY single one of my functions need to accept the address of a virtual entity so that I can switch between virtual and real hardware... something doesn't seem right.

In the TDD book, they use virtualLEDs as a way to test if the LED register is being set correctly.  But, in my case, I need to set lots of registers.  How can I unit test that?

Well, let's start at the bottom.  I need to write a function that simply sets a bit, forget about which register, just any register.
-------------------------------------------------------------------------------------------

12:46 PM 11/23/2020

Set up the RCC gpio port clock enable during the initialization routine.

Time to set up I/O pin configuration... but I'm a bit stuck.  I know that I need a way to select between all the ports, pins, AND modes.  On top of any other configuration details if the mode is an alternate function or analog I/O.  How can I manage this?  I can't just use nested switch statements everywhere.
  -> I'm hazarding a guess that I need to build down before I can build up.  I.E. I need functionality that does each one of these things one at a time.

The issue is, configuration options in these registers is all over the place.  Some config options are 1 bit wide, some are 2 bits wide... some more.  On top of that, they happen in different registers.
  -> Maybe this is where the human configuration struct is useful... I can set up the configuration in plain english for a pin.  THEN, I can have a DGD_ConfigureGPIOPin() function to decypher all the english into bits and registers without the client having to worry about it.

For example, GPIOx_MODER register needs 2 bits at a certain location to set a GPIO pin as input/output/alternate function/analog .  2 bits... at some location.  I'd think I could use this as a way to create a generalized function.

Something like...
DGD_SetRegisterField(uint32_t *regAddr, uint8_t width, uint8_t location, uint8_t setting)

Then I could do something like

/* Create bit mask from bit field width */
uint32_t bitMask = 0;
int i = width;
while(i > 0)
{
    bitMask |= (1 << i);
    i--;
}

/* Configure the bits to correct setting */
bitMask = bitMask & (~bitMask | setting);

/* Move bit mask to correct position */
bitMask = bitMask << location;

/* Finally merge the configured bit mask into the register */
... NO NO NO... this doesn't work well.

-------------------------------------------------------------------------------------------

2:17 PM 11/24/2020

Finally reaching out to people for ideas on how to mount this interface issue... I don't know how to create a easily manageable way to modify lots of registers and subfields.

One suggestion I received is to make a GPIO_Port_t type (which I already have) but to associate the base address of the PORT register with the type.  Then somehow use this type to associate the address offsets for all the individual registers and bits of each port.  Not clear yet but some light at the end of the tunnel...


Here's what I know.  My PORT register offset can be encapsulated in a struct:

typedef struct
{
  __IO uint32_t MODER;    /*!< GPIO port mode register,               Address offset: 0x00      */
  __IO uint32_t OTYPER;   /*!< GPIO port output type register,        Address offset: 0x04      */
  __IO uint32_t OSPEEDR;  /*!< GPIO port output speed register,       Address offset: 0x08      */
  __IO uint32_t PUPDR;    /*!< GPIO port pull-up/pull-down register,  Address offset: 0x0C      */
  __IO uint32_t IDR;      /*!< GPIO port input data register,         Address offset: 0x10      */
  __IO uint32_t ODR;      /*!< GPIO port output data register,        Address offset: 0x14      */
  __IO uint32_t BSRR;     /*!< GPIO port bit set/reset register,      Address offset: 0x18      */
  __IO uint32_t LCKR;     /*!< GPIO port configuration lock register, Address offset: 0x1C      */
  __IO uint32_t AFR[2];   /*!< GPIO alternate function registers,     Address offset: 0x20-0x24 */
} GPIO_TypeDef;


Then, each specific port can be accessed like this:

#define GPIOA               ((GPIO_TypeDef *) GPIOA_BASE)
#define GPIOB               ((GPIO_TypeDef *) GPIOB_BASE)
#define GPIOC               ((GPIO_TypeDef *) GPIOC_BASE)


I.E.

GPIOA->MODER to set the MODER register of PORTA.  Great.  But, I still need a way to access this inside a function.

Maybe I can do something like

Write_GPIO_Pin(GPIO_TpeDef *port, uint8_t pin, uint8_t level)
{
  port->MODER = // set to output
  port->ODR = // set correct pin to output
}



-------------------------------------------------------------------------------------------

12:11 PM 11/25/2020

I think I'm doing something fundamentally flawed.  My interface design doesn't really hide details of the inner workings.

If I'm a client of dc_gpio_driver.h, all I want to be able to do is... do things like this:

DGD_Write_GPIO_Pin(port, pin, level) // unsure about what the type of each argument should be

Maybe the gpio_driver interface can provide the client with a list of possible options.  In fact, it SHOULD.  To prevent the client from having to dig into the driver code AT ALL.  Like... I don't want the client to be reponsible for comming up with the correct address.  That would be insane... what's even the point of my driver if the client has to go into the datasheet or the MCU specific header file.  Pointless..

Ok so I know that my driver should offer the functions and the OPTIONS for the functions that the client should know about.  Like... a radio interface.  Only certain knobs are exposed and only certain knob values can be achieved unless the knob is like a potentiometer.


-------------------------------------------------------------------------------------------

1:34 PM 11/27/2020

Well I finally got a basic GPIO interface going.  It's still rough.  The associated tests are even more rough.  Not super happy about how development for this has gone but at least I learned how to make a basic GPIO interface as a starting point.  Where can I go next?

Well, let's flesh out the GPIO driver interface.



-------------------------------------------------------------------------------------------

4:46 PM 11/28/2020

Getting a warning I don't understand.

warning: passing argument 1 of 'DGD_SetBit' makes pointer from integer without a cast [-Wint-conversion]

-->function declaration
void DGD_SetBit(uint32_t *address, uint8_t bit)

-->function call
DGD_SetBit(activeGPIOhandle.portRegisters->MODER, 0);

What I don't get is... the function expects a pointer to uint32_t.  OOOOH.  I'm passing in the VALUE of the register.  I need to pass in the address.

Fixed it... SetBit() and ClearBit() should have volatile qualifier on the first parameter since they pretty much always modify hardware registers.  If I happen to pass in a register that is not tied to actual hardware, I only lose out on a bit of optimization.

At some point I need to graduate past making snail paced progress on the GPIO driver.  Trying to finish up write/read GPIO functionality.

Order this book: "Small Unmanned Aircraft: Theory and Practice"



-------------------------------------------------------------------------------------------

4:01 PM 11/29/2020

It's becoming evident that I am trying to invest too much energy into making the GPIO driver perfect.  While at the same time trying to think about how to make the lessons I learn making the GPIO driver applicable to other drivers.  Or to embedded programming in general.  There's so much to think about and I trying to do it all in parallel is REALLY slowing me down.  It might be smarter to try finishing the GPIO driver to the best of my ability for now and moving on to other interfaces (like maybe an interrupt management interface since most likely that will be used in lots of places anyway).  That way I don't have to spend too much time worrying about what's worth working on next.  Just pick the most general pieces and move inward towards the final solution.

So in my case, it might be wise to finish my GPIO driver interface with 
DGD_InitPort(enum port) // turn on RCC to port
DGD_DeInitPort(enum port) // maybe turn off (tri-state) the output pins and turn off RCC to port
DGD_SetPinDirection(enum port, pin, mode)
DGD_WritePin(enum port, pin, level)
DGD_ReadPin(enum port, pin)


Just as a comparison point, looking through my old flight controller project, I didn't do a great job of defining the interfaces clearly out of modules.  There's so much overlap, i.e. motorControl.c has a PUBLIC function named GatherSensorData()... no way does that make sense.  I'm inputting sensor aquisition logic into the motorControl driver... no.  Now it MAY be possible that I meant this function to be internal and private to the motorControl, but if that's the case I totally forgot to prefix it as "static".  Yeah, either way I look at it, the lesson is that motorControl seems to have logic associated with sensor data and that just doesn't make sense.  So I am learning!  Yaya!

So I've written WritePin() and ReadPin() and I've also written the unit tests for that.  It would be good to actually pull out hardware and test if real pins are being utilized correctly.

Let's try to set PB5 to output mode.  And try to toggle it.  It's hooked up to my saleae.


-------------------------------------------------------------------------------------------

11:45 AM 11/30/2020

Well.. I did that.  I now have a tested GPIO driver interface for basic funtionality.  I have absolutely no alternative function implementation at this time, just setting pins HIGH/LOW outputs and reading inputs.

Pretty soon I will want to set up something like an SPI driver so I will need to set AF on pins...

The thing is, GPIO took me a long time to develop.  I'm sick of looking at datasheets...  can I work on something different for a while?  Maybe start work on the main flight stack... and unit testing everything.

However I can't just jump into the deep end of code... I don't really know how to architect it in a safe way.

All I know at this point is that I will want some type of structure like this
main.c->Calls init functions and then launches RTOS scheduler
RTOS Scheduler->Should contain tasks that do things like:
	- gather sensor data
	- calculate PID from current state and future state command
	- translate PID values to actual motor control values
	- gather commands from radio

The reality is that a lot of these should be grouped together into the same task as they need to happen very closely in time (efficiently) and they are dependent on eachother to operate at the same speed.  It would take more time to organize multiple tasks and try to keep them synced.

The tasks that depend on eachother to happen at the same time are... gathering sensor data, calculating PID from data, and updating the motor control value.  Those happen at the same time.

At this point, I can transition to RTOS and try to set it all up... but genuinelyl don't want to do that yet.  I want to stay on the topic of unit testing basic functionality.  

I can start work on the PID.  But the fibers in my being tell me that I should transition to writing the SPI driver instead.  Ok I'll start out with constructing the SPI power point.


-------------------------------------------------------------------------------------------

12:27 PM 12/2/2020

Yesterday I actually got to a working version of the SPI driver.  I can send data out of MOSI and SCK.  Haven't tested MISO yet.

One immediate concern is I'm unclear about how to set the clock properly.  There are a few bits for a clock divider (I'm guessing a divider for APB2 clock but honestly I'm not sure).
	fPCLK ... what is it?  It's a divider for this clock.
	According to documentation fPCLK1 and 2 are internal APB1 and APB2 respectively.
	-> Well I know SPI1 is on APB2 so I'm going to go with that.
		--> fPCLK2 max (APB2) is apparently 84MHz
		--> I don't have a good way to see the current APB2 frequency... 
		--> but I do know my current SPI SCK is running at... 500kHz by confirming with logic analyzer
		--> I also know my SPI divider is set to 32
			--> This means APB2 = 32 * 500 kHz = 16MHz .  Is this correct?
			--> Yes sir, this is correct.  I never touched the default CubeMX setup and CubeMX claims APB2 is at 16MHz by default.  Sweet!

Well I can modulate 16 MHz for now, just divide it down.  I don't think I need anything faster.  The only real issue is I can only do powers of 2 as the dividers... is that ok?



-------------------------------------------------------------------------------------------

4:52 PM 12/3/2020

I noticed my nRF24L01 radio can do SPI from 0 to 8 Mbps.  Considering my APB2 clock runs at 16 MHz, I can divide it by two and max out my SPI comms.

But to be safe, I'll divide by 4 and run at 4 Mbps... confirm with scope.  This frequency will also put it barely in range for my scope to be able to read.

Oh yes.  It runs perfectly, no problems here.

Figured out that if I wait for TXE bit to be set in SPI_SR register, I can send bytes one after another.  It's much better than using HAL_Delay(1) which adds way too much delay.  This seems to be instantaneous, though I am having to wait for the bit to be set some some processor cycles are wasted inside the while loop.  But, at the very least, this is proof of concept.  Needs to be cleaned up though.



-------------------------------------------------------------------------------------------

9:31 PM 12/4/2020

Wasn't able to get much done today because I spent a lot of time outside.  But I did manage to polish off the MAKEFILE and to implement MISO read while MOSI transmits in the SPI driver.

I was going to try and optimize the MAKEFILE build system as... at the moment... it builds ALL the files every single time.  It takes about 6 seconds to build now so I can deal with it but slowly I'll have to convert to a more optimized build.  I'm not exactly at the point where I understand WHY every single file is compiling every single time.  I thought make automatically manages which files haven't been touched and doesn't recompile them but I guess not... I have to organize something which I don't understand at the moment.

That being said, since my SPI driver is pretty good at this point, I should try it out on the LoRa SPI radio module I have sitting around.  I think I'm asking for a world of hurt as I try to implement this monster but I don't have any better ideas for how to actually try and use my SPI driver in the wild.

To read data from LoRa radio, apparently all I need to do is load a slave register address I want and then pump out 8 more bits after that (dummy bits) so that the MISO line can clock enough times.

What I don't understand, though, is the difference between a read and a write in SPI.  Apparently SPI is read/write agnostic since MOSI and MISO are used.  This means the end devices (slave and master) need to each implement their own interpretation scheme for what they should actually do when these bits are moving around.

So I'm kinda stuck... I don't understand where my radio has the SPI read register sequence.  They make it seem like there's a "read" command but I can't find it.

And... after wasting some time, I realized I overlooked someting very clear in the datasheet.  I don't know how I missed it but I did.  There's a wnr bit (1 if write, 0 if read) in the register address byte.  What I'm not clear on is if it's the 0th bit or the 7th.  I think it's the 0th, I'll try that first.

The only other thing that's missing is I need to drive an NSS pin high/low... I was relying on hardware doing this for me but it doesn't seem to do that.



-------------------------------------------------------------------------------------------

10:55 AM 12/6/2020

LoRa radio seems to have the following needs (from studing the RadioHead library):

In order to send a packet, I need to send several bytes to the same SPI register on the LoRa radio.  Namely register 0x00 (RegFifo).  Writing to this register automatically increments some FIFO somewhere that I'm not clear on.

But the code look like this:

spiWrite(0x00, txHeaderTo)   (??)
spiWrite(0x00, txHeaderFrom) (??)
spiWrite(0x00, txHeaderId)   (??)
spiWrite(0x00, txHeaderFlags)(??)
spiWriteBytes(0x00, data, len)

then write the payload length

spiWrite(0x22, len + HEADER_LEN)

then turn on radio...

setModeTx()
	I've yet to trace exactly what this function does, but most likely since the radio has all the bits it needs at this point inside its registers (inside the FIFO buffer specifically), all I should need to do is turn on a single bit somewhere to start the radio.

According to the documentation:
	-> It is possible to store both transmit and receive information in the FIFO at the same time
	-> Tx and Rx base addresses are fully configurable across the 256 byte memory area of the buffer
	-> By default the device is configured to have Tx pointer at 0x80 (halfway) and Rx pointer at 0x00
	-> The FIFO buffer is cleared when device is put in SLEEP mode
	-> Cannot access FIFO while in SLEEP mode, can use something like STANDBY mode instead
	-> The actual location to read from or write to over the SPI interface is defined by the address pointer FifoAddrPtr.  Before any read or write operation it is necessary to initialize this pointer to the corresponding base value.  Upon reading or writing to the FIFO data buffer (RegFifo) the address pointer will then increment automatically.
	-> Register FifoRxBytesNb defines how many bytes to expect when receiving data from radio
	-> PayloadLength register indicates size of memory location to be transmitted.  Basically when radio gets turned on the radio starts at Tx pointer and sends PayloadLength bytes out over radio.

I think I have a very basic understanding of how the LoRa radio works at this point.  I think it's worth starting a very basic driver for it.